# Text to MIDI parser
#   by memorecks and boomninjavanish
#    July 20 2022

import isobar as iso
import configparser
import csv
from datetime import datetime

class MidiBot:
    """Generate MIDI data with text commands.

    Creates a virtual MIDI device and a sequencer that can be
    picked up in any DAW or MIDI-enabled app.

    MIDI data is generated by providing revieve_message() with a string.
    If the command trigger is used, we try to execute the command and respond back
    to the user with relevant information.

    Note range      c0-g8
    Value range     0-127
    Duration range  0.1-999999

    Example commands:
    !add synth a4[4] c3[4] f2[0.5] c#4[1]
        (Specify track, note names and durations)
    !add synth c3 d3 e3 f4
        (Duration defaults to 1 if not specified)
    !add synth a2-c3-e3[4] g2-b2-d3-f3[8]
        (Chords use dashes to combine notes)
    !res 0 100 40 45
        (CC durations also default to 1)
    !cutoff loop 30[4] 100[4] 127[8]
        (Looped CC commands)
    !macro macro1 c3-c4[4]
        (Create a macro named 'macro1')
    !add synth $macro1
        (Reference the macro)
    """

    def __init__(self):
        self.log('MidiBot initated')
        # Create the MIDI output device and Timeline object
        self.midi_output = iso.MidiOutputDevice(device_name='midibot', virtual=True)
        self.timeline = iso.Timeline(tempo=120,output_device=self.midi_output)
        # We should be giving isobar clean values, and handle all exceptions before it
        # So let's live dangerously and ignore exceptions
        self.timeline.ignore_exceptions = True
        # Init our settings
        self.command_trigger = "!"
        self.macro_prefix = "$"
        self.macrodict = {}
        self.ccdict = {}
        self.trackdict = {}
        self.duration_limit = 999999
        self.notify_on_success = False
        self.load_macros()
        # Load settings from file
        try:
            self.load_general_settings()
            self.load_cc_settings()
            self.load_track_settings()
            self.log('Settings files loaded successfully')
        except:
            # Write to log file
            self.log(
                message = 'Failed to load configuration files',
                type = 'Error',
                username = '@System'
            )
        # Start the timeline, do this once or else threads
        self.start()

    def log(self, message, type='Log', username='@System'):
        """Append message to log file.
        message:    -> str
        type:       -> str, type of message
        username:   -> str, message source
        """

        # Do not print commands to console
        if type != 'Command':
            print(f'{type}: {message}')
        # Log format: Date:Time, EventType, Username, Message
        now = datetime.now()
        current_time = now.strftime("%D:%H:%M:%S")

        # Write to CSV
        with open('midibot/logs/log.csv','a') as fd:
            fd.writelines(f'{current_time}, {type}, {username}, {message}\n')

    def create_config(self):
        """Create a new config file.
        This is currently unused.
        """

        config = configparser.ConfigParser()
        config['SECTION'] = {'Key' : 'Value'}
        with open('configwrite.ini', 'w') as configfile:
            config.write(configfile)

    def load_cc_settings(self):
        """Load MIDI CC mappings from .ini file."""

        config_file = 'midibot/settings/midimap.ini'
        config = configparser.ConfigParser()
        config.read(config_file)
        sections = config.sections()
        for section in sections:
            self.ccdict[section.lower()] = [config[section]['CH'], config[section]['CC']]
        # Print CC settings to terminal
        for key, value in self.ccdict.items():
            print (f'\t{key}\t[CH] {value[0]} [CC] {value[1]}')
        print('')
    
    def load_track_settings(self):
        """Load MIDI Track mappings from .ini file."""

        config_file = 'midibot/settings/trackmap.ini'
        config = configparser.ConfigParser()
        config.read(config_file)
        sections = config.sections()
        for section in sections:
            if section.lower() == 'tracks':
                for key in config[section]:
                    self.trackdict.update({key:int(config[section][key])})
        # Print tracks to terminal
        for key in self.trackdict:
            print(f'\t{key}: \t[CH] {self.trackdict[key]}')
        print('')

    def load_general_settings(self):
        """Load general settings from .ini file.
        We are looking for:
            Command Trigger
            Macro Prefix
        This can be modified to load more settings.
        """

        config_file = 'midibot/settings/settings.ini'
        config = configparser.ConfigParser()
        config.read(config_file)
        sections = config.sections()
        for section in sections:
            if section.lower() == 'settings':
                for key in config[section]:
                    if key.lower() == 'trigger':
                        self.command_trigger = config[section][key]
                    elif key.lower() == 'macroprefix':
                        self.macro_prefix = config[section][key]
        # Print settings to terminal
        print(f'\tTrigger: {self.command_trigger}\n\tMacro Prefix: {self.macro_prefix}\n')

    def start(self):
        """Starts the timeline/sequencer in a background thread."""

        # Do this once, as it will start multiple threads
        self.timeline.background()

    def clear(self):
        """Clears sequencer of all tracks and resets BPM to 120."""
        # TODO: Reset all CC commands to 0 also?
        self.timeline.clear()
        self.set_tempo(120)
        # isobar.Timeline doesn't have a function for this
        # so lets stop all the notes from hanging
        for device in self.timeline.output_devices:
            device.all_notes_off()

    def set_tempo(self, tempo):
        """Sets the BPM of sequencer. 
        tempo -> int
        Try not to exceed 600 BPM, or the clock may lag.
        """

        self.timeline.tempo = tempo

    def add_notes(self, notes, durations, amplitudes, channel=0, replace=False):
        """Adds notes to the sequencer.
        This should be called after parse_notes() and make_sequence()
        notes       -> int - iso.PSequence or similar type object
        durations   -> float - iso.PSequence or similar
        amplitudes  -> int - static value from 0-127
        channel     -> int - MIDI channel 0-15
        """
        
        self.timeline.schedule({
            "note": notes,
            "duration": durations,
            "amplitude": amplitudes,
            "channel": channel
        }, quantize=1, name=channel, replace=replace)

    def add_cc(self, control, values, durations, channel=0, loop=False):
        ### THIS HAS BEEN UPDATED ###
        ### WIP ###

        """Adds MIDI CC messages to the sequencer.
        This should be called after parse_values()
        control     -> int - MIDI CC number 0-127
        values      -> list, int - CC value 0-127
        durations   -> list, float -  The duration of those values
        channel     -> int - Which MIDI channel 0-15
        loop        -> bool - If a looped CC sequence specified

        Update: New version of isobar on github has new options.
            - We can now name each track
            - We can now replace tracks based on name
                - Note: this only replaces 1 track, not all with the same name
        """

        if loop == True:
            # interpolation needs at least 2 values, so lets check
            if len(values) > 1:
                self.timeline.schedule({
                    "control": control,
                    "value": iso.PSequence(values),
                    "duration": iso.PSequence(durations),
                    "channel": channel
                }, interpolate='linear', name=f'{control}-{channel}', replace=True)
            else:
                raise ValueError('Looped controls need at least 2 values')
        else:
            if len(values) > 1:
                self.timeline.schedule({
                    "control": control,
                    "value": iso.PSequence(values),
                    "duration": iso.PSequence(durations),
                    "channel": channel
                }, interpolate='linear', count=len(values), remove_when_done=True, name=f'{control}-{channel}', replace=True)
            elif len(values) == 1:
                # since there is only 1 value, take off interpolation
                # TODO: find interpolation none object
                # When replace=True, the interpolation and all that needs to change too
                 self.timeline.schedule({
                    "control": control,
                    "value": iso.PSequence(values),
                    "duration": iso.PSequence(durations),
                    "channel": channel
                }, count=len(values), remove_when_done=True, name=f'{control}-{channel}', replace=True)

    def string_to_note(self, string):
        """Convert note name to int.
        Limit: c0 - g8 or 24 - 127
        We cannot use negative octaves because the '-' char is used to specify chords.
        """

        try:
            note_number = int((iso.note_name_to_midi_note(str(string).upper()) + 24))
        except:
            raise ValueError('Unknown note name. Enter a note from c0 - g8')

        if 0 <= note_number <= 127:
            return note_number
        else:
            raise ValueError('Note out of range. Enter a note from c0 - g8')

    def parse_notes(self, message):
        """Converts a string into lists of notes and durations.
        Takes a message like: "c3[1] d3[2] e2[4] f#3[0.5]"
        And parses to 2 lists: 
            notenumbers:    [60, 62, 52, 66]
            durations:      [1.0, 2.0, 4.0, 0.5]
        """

        # Split message into list of words
        messages = str(message).split(' ')
        # Initialize vars, we will store our sequence here
        notenumbers = []
        durations = []
        
        for message in messages:
            note_is_valid = False
            # Strip last bracket, and split into list by opening one
            # This should result in y[0] as note and y[1] as duration
            y = message.strip(']')
            y = y.split('[')

            # Check is a rest was specified, and append None if so
            # Currently, we do not allow a rest as a chord note
            if y[0] == 'rest':
                notenumbers.append(None)
                note_is_valid = True
            else:
                # Check if a chord is specified
                if '-' in y[0]:
                    # Split notes into lest separated by '-'
                    chord_notes = y[0].split('-')
                    chord = []

                    for chord_note in chord_notes:
                        try:
                            chord.append(self.string_to_note(chord_note))
                            note_is_valid = True
                        except ValueError as v:
                            raise ValueError(v)
                    # isobar needs a tuple to make chords
                    chord = tuple(chord)
                    notenumbers.append(chord)
                else:
                    try:
                        notenumbers.append(self.string_to_note(y[0]))
                        note_is_valid = True
                    except ValueError as v:
                        raise ValueError(v)

            # Check if a duration is specified, If not, default to 1
            if len(y) > 1 and note_is_valid:
                try:
                    # Let's limit duration to 4 decimal points
                    duration = round(float(y[1]), 4)
                except:
                    raise ValueError(f'Duration should be a number from 0.1 - {self.duration_limit}')

                # Check to see if its within our range of durations
                if 0.1 <= duration <= self.duration_limit:
                    durations.append(duration)
                else:
                    raise ValueError(f'Duration not in valid range of 0.1 - {self.duration_limit}')
            elif len(y) == 1 and note_is_valid:
                durations.append(1)
        return notenumbers, durations

    def parse_values(self, message):
        """Converts a string into lists of values and durations
        Takes a message like: "100[1] 0[4] 25[0.5] 127[4]"
        And parses to 2 lists: 
                   values: [100, 0, 25, 127]
                durations: [1.0, 4.0, 0.5, 4.0]        
        """

        # Make the message into a list of words separated by ' '
        messages = str(message).split(' ')

        # Init local vars.. we will store the parsed values and durations here
        values = []
        durations = []

        # Iterate and inspect every word
        for i in messages:

            # Testing using a local var
            # # Set to False, and only set True if pass checks 
            value_is_valid = False
            
            # Strip last bracket, and split into list by opening one
            # This should result in y[0] as value and y[1] as duration
            y = i.strip(']')
            y = y.split('[')

            # First, lets check if they said 'rest' and append None if so
            if y[0] == 'rest':
                values.append(None)
                value_is_valid = True

            # If not a rest, let's make sure it's a valud value
            elif y[0].isdigit():
                value = int(y[0])
                if 0 <= value <= 127:
                    values.append(value)
                    value_is_valid = True
                else:
                    raise ValueError('Value not in range of 0-127')

            # If it didn't pass those checks, it's a bad command!
            else:
                raise ValueError('Value should be an integer from 0-127')
                
            # Check if a duration is specified, If not default to 1
            if len(y) > 1 and value_is_valid:
                try:
                    # Let's limit duration to 4 decimal points
                    duration = round(float(y[1]), 4)
                except:
                    raise ValueError(f'Duration should be a number between 0.1 - {self.duration_limit}')

                # Check to see if its within our range of durations
                if 0.1 <= duration <= self.duration_limit:
                    durations.append(duration)
                else:
                    raise ValueError(f'Duration not in range of 0.1 - {self.duration_limit}')
            elif len(y) == 1 and value_is_valid:
                durations.append(1)
        return values, durations

    def make_sequence(self, notes, durations, command_name, channel=0):
        """Takes a list of notes and durations and makes a MIDI sequence.
        This is usually called after parse_notes().
        Here, we define if the sequence if normal or a random type.
        notes           -> int - List of notes
        durations       -> float - List of durations
        command_name    -> str - Type of sequence to make
        channel         -> int - MIDI channel
        """

        # We want a validated input here. This is handled in the parse functions
        if command_name == 'add':
            note_sequence = iso.PSequence(notes)
            duration_sequence = iso.PSequence(durations)
            self.add_notes(note_sequence, duration_sequence, 127, channel)
        if command_name == 'rand':
            note_sequence = iso.PWhite(notes[0],notes[1])
            duration_sequence = iso.PChoice(durations)
            self.add_notes(note_sequence, duration_sequence, 127, channel)
        if command_name == 'choice':
            note_sequence = iso.PChoice(notes)
            duration_sequence = iso.PChoice(durations)
            self.add_notes(note_sequence, duration_sequence, 127, channel)

        if command_name == 'replace':
            # Check for existing tracks and delete them
            # There is a function within each track to replace
            # But we might have multiple tracks for each channel
            # see track.event_stream to append events later
            # or... maybe we run a var called self.note_stream

            for index, track in enumerate(self.timeline.tracks):
                if track.name == channel:
                    self.timeline.unschedule(self.timeline.tracks[index])        
                    for device in self.timeline.output_devices:
                        device.all_notes_off()

            note_sequence = iso.PSequence(notes)
            duration_sequence = iso.PSequence(durations)
            self.add_notes(note_sequence, duration_sequence, 127, channel, True)

        # WIP, this doesn't work too good
        if command_name == 'append':
            for track in self.timeline.tracks:
                note_sequence = iso.PSequence(notes)
                duration_sequence = iso.PSequence(durations)
                print(track.name)
                print(track.event_stream.dict)
                og_note_seq = track.event_stream.dict['note']
                og_dur_seq = track.event_stream.dict['duration']
                note_sequence = iso.PConcatenate([og_note_seq, note_sequence])
                duration_sequence = iso.PConcatenate([og_dur_seq, duration_sequence])
                self.add_notes(note_sequence, duration_sequence, 127, channel)

    def load_macros(self):
        """Load macros from csv file into self.macrodict"""
        try:
            with open("midibot/logs/macros.csv", "r") as f:
                reader = csv.reader(f, delimiter=",")
                for line in reader:
                    self.macrodict.update({line[0]:line[1]})
            print(self.macrodict)
        except:
            self.log('Could not load macros from file')

    def make_macro(self, message):
        """Add user macro to dict."""

        messages = message.split(' ')
        if len(messages) >= 2:
            name = messages.pop(0)
            message = ' '.join(messages)
            self.macrodict.update({name:message})
            # Write to file
            with open('midibot/logs/macros.csv','a') as fd:
                fd.writelines(f'{name},{message}\n')
        else:
            raise ValueError('Could not create macro. Usage: !macro <name> <message>')

    def undo(self):
        """Remove last track added to sequencer"""

        try:
            # Remove the last track in list
            self.timeline.tracks.remove(self.timeline.tracks[-1])
            # Send 'Stop Notes' to all Midi output devices
            for device in self.timeline.output_devices:
                device.all_notes_off()
        except:
            raise ValueError('No track to undo')

    def recieve_message(self, message, username='default_user'):
        """Converts string to MIDI and returns a response message.
        This is our main function, and should be the only one called on the outside.
        The response string can be interpreted as follows:
            None:   No command trigger specified
            '':     Command successful
            Else:   Command unsuccessful, see message
        """

        # Leave response empty if command successful.
        response = ''
        message = message.lower()

        # Check if the command trigger is used
        if len(message) > 0 and message[0] == self.command_trigger:

            # Strip command trigger
            message = message[1 : : ]

            # Write the command to log file
            self.log(message, 'Command', username)

            # Split into list of words (messages)
            messages = message.split(' ')

            # Macro replacement (WIP)
            for index, word in enumerate(messages):
                if len(word) > 0 and word[0] == self.macro_prefix:
                    word = word[1 : : ]
                    for key in self.macrodict:
                        if key in word:
                            word = word.replace(key, self.macrodict[key])
                            messages[index] = word
                            # We are only returning the first result for now
                            break

                    # if word in self.macrodict:
                    #     messages[index] = self.macrodict[word]

            # The first word in this list should be the command name
            command_name = messages.pop(0)
            
            # Check if the command is in our config file 
            if command_name in self.ccdict:
                channel = int(self.ccdict[command_name][0])
                control = int(self.ccdict[command_name][1])
                loop = False
                try:
                    if messages[0] == 'loop':
                        del messages[0] # delete the word 'loop'
                        # Check if there are any values specified
                        if len(messages) == 0:
                            response = 'This command requries at least 2 values between 0-127'
                            return response
                        else:
                            loop = True
                    else:
                        loop = False
                    message = ' '.join(messages)
                except:
                    response = 'Enter a value from 0-127 after your command'

                # Try to parse into a valid MIDI message
                if message != '' and message is not None:
                    try:
                        values, durations = self.parse_values(message)
                        self.add_cc(control, values, durations, channel, loop)
                    except ValueError as v:
                        response = v
                else:
                    response = 'Enter a value from 0-127 after your command'

            elif command_name == 'add' or command_name == 'choice' or command_name == 'rand' or command_name == 'replace' or command_name == 'append':
                try:
                    if messages[0] in self.trackdict:
                        channel = self.trackdict[messages.pop(0)]
                        message = ' '.join(messages)
                        # Check if any notes specified
                        if message != '' and message is not None:
                            try:
                                notes, durations = self.parse_notes(message)
                                self.make_sequence(notes, durations, command_name, channel)
                            except ValueError as v:
                                response = v
                        else:
                            response = 'This command requires values after it'
                    else:
                        response = 'Could not find instrument. Usage: !add <instrument> <notes>'
                except:
                    response = 'Please specify an instrument track. Usage: !add <instrument> <notes>'
            elif command_name == 'macro':
                try:
                    message = message.replace(f'{command_name} ', '')
                    self.make_macro(message)
                except ValueError as v:
                    response = v

            elif command_name == 'clear' or command_name == 'reset':
                try:
                    self.clear()
                except:
                    response = 'Could not clear timeline'
            elif command_name == 'undo':
                try:
                    self.undo()
                except ValueError as v:
                    response = v        
            elif command_name == 'bpm' or command_name == 'tempo':
                try:
                    message = message.strip(command_name)
                    message = message.strip(message[0]) # leftover whitespace
                    if int(message) > 0 and int(message) <= 500:
                        self.set_tempo(int(message))
                    else:
                        response = 'BPM must be whole number from 1-500'
                except:
                    response = 'BPM must be whole number from 1-500'
            elif command_name == 'help':
                response = 'Enter a command followed by a value between 0 and 127. Available commands: '
                for key in self.ccdict:
                    response = response + f'{self.command_trigger}{key} '
                response = response + '. Available tracks: '
                for key in self.trackdict:
                    response = response + f'{key} '
            else:
                response = 'Command not found'
        else:
            response = None
            return response
        
        return response

if __name__ == '__main__':
    midi = MidiBot()
    while True:
        message = input('Command: ')
        error_message = midi.recieve_message(message)
        if error_message == None:
            pass
        elif error_message != '':
            print(f'\t{error_message}')
        else:
            print('\tCommand successful')
